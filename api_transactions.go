/*
Blockdaemon DeFi API

The Blockdaemon DeFi API provides a single interface to a multitude of DeFi projects and blockchains

API version: 1.0.0
Contact: info@blockdaemon.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TransactionsAPIService TransactionsAPI service
type TransactionsAPIService service

type ApiGetTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	chainID *string
	accountAddress *string
	limit *int32
	page *string
}

// The CAIP-2 identifier for a blockchain.
func (r ApiGetTransactionsRequest) ChainID(chainID string) ApiGetTransactionsRequest {
	r.chainID = &chainID
	return r
}

// The address of an account.
func (r ApiGetTransactionsRequest) AccountAddress(accountAddress string) ApiGetTransactionsRequest {
	r.accountAddress = &accountAddress
	return r
}

// The number of items per page.
func (r ApiGetTransactionsRequest) Limit(limit int32) ApiGetTransactionsRequest {
	r.limit = &limit
	return r
}

// The page token/number for pagination.
func (r ApiGetTransactionsRequest) Page(page string) ApiGetTransactionsRequest {
	r.page = &page
	return r
}

func (r ApiGetTransactionsRequest) Execute() (*TransactionsResponse, *http.Response, error) {
	return r.ApiService.GetTransactionsExecute(r)
}

/*
GetTransactions Get transaction history for an account

Retrieves the transaction history for a given account on a specified blockchain network. The response includes details about each transaction, such as the timestamp, transaction type, chain ID, block information, transaction hash, explorer links, status, involved accounts, token amounts, gas costs, and any associated token transfers. This endpoint allows users to review their past transactions and monitor their on-chain activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTransactionsRequest
*/
func (a *TransactionsAPIService) GetTransactions(ctx context.Context) ApiGetTransactionsRequest {
	return ApiGetTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionsResponse
func (a *TransactionsAPIService) GetTransactionsExecute(r ApiGetTransactionsRequest) (*TransactionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chainID == nil {
		return localVarReturnValue, nil, reportError("chainID is required and must be specified")
	}
	if r.accountAddress == nil {
		return localVarReturnValue, nil, reportError("accountAddress is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit < 1 {
		return localVarReturnValue, nil, reportError("limit must be greater than 1")
	}
	if *r.limit > 100 {
		return localVarReturnValue, nil, reportError("limit must be less than 100")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chainID", r.chainID, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountAddress", r.accountAddress, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
