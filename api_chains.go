/*
Blockdaemon DeFi API

The Blockdaemon DeFi API provides a single interface to a multitude of DeFi projects and blockchains

API version: 1.0.0
Contact: info@blockdaemon.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ChainsAPIService ChainsAPI service
type ChainsAPIService service

type ApiGetChainsRequest struct {
	ctx context.Context
	ApiService *ChainsAPIService
	chainID *string
	chainName *string
	networkType *NetworkType
}

// The CAIP-2 identifier for a blockchain.
func (r ApiGetChainsRequest) ChainID(chainID string) ApiGetChainsRequest {
	r.chainID = &chainID
	return r
}

// The name of a blockchain.
func (r ApiGetChainsRequest) ChainName(chainName string) ApiGetChainsRequest {
	r.chainName = &chainName
	return r
}

// The type of network (mainnet, testnet, or devnet).
func (r ApiGetChainsRequest) NetworkType(networkType NetworkType) ApiGetChainsRequest {
	r.networkType = &networkType
	return r
}

func (r ApiGetChainsRequest) Execute() (*Chains, *http.Response, error) {
	return r.ApiService.GetChainsExecute(r)
}

/*
GetChains Get supported blockchain networks with metadata

Retrieves metadata about each supported blockchain network, such as the chain name, CAIP-2 identifier, network type (mainnet, testnet, or devnet), chain icon URI, estimated block time, required block confirmations, RPC gateways, native currency details, and block explorer URLs. This information is useful for displaying chain details and configuring interactions with different blockchains.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChainsRequest
*/
func (a *ChainsAPIService) GetChains(ctx context.Context) ApiGetChainsRequest {
	return ApiGetChainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Chains
func (a *ChainsAPIService) GetChainsExecute(r ApiGetChainsRequest) (*Chains, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chains
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChainsAPIService.GetChains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chainID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainID", r.chainID, "")
	}
	if r.chainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainName", r.chainName, "")
	}
	if r.networkType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkType", r.networkType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
