/*
Blockdaemon DeFi API

The Blockdaemon DeFi API provides a single interface to a multitude of DeFi projects and blockchains

API version: 1.0.0
Contact: info@blockdaemon.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// ExchangeAPIService ExchangeAPI service
type ExchangeAPIService service

type ApiGetRoutesRequest struct {
	ctx context.Context
	ApiService *ExchangeAPIService
	fromChain *string
	fromAmount *string
	fromToken *string
	toChain *string
	toToken *string
	fromAddress *string
	toAddress *string
	slippage *float32
	allowBridges *[]string
	allowExchanges *[]string
	denyBridges *[]string
	denyExchanges *[]string
}

// The sending blockchain in CAIP-2 notation.
func (r ApiGetRoutesRequest) FromChain(fromChain string) ApiGetRoutesRequest {
	r.fromChain = &fromChain
	return r
}

// The amount of tokens to be sent, including decimals.
func (r ApiGetRoutesRequest) FromAmount(fromAmount string) ApiGetRoutesRequest {
	r.fromAmount = &fromAmount
	return r
}

// The address or symbol of the token to be transferred.
func (r ApiGetRoutesRequest) FromToken(fromToken string) ApiGetRoutesRequest {
	r.fromToken = &fromToken
	return r
}

// The receiving blockchain in CAIP-2 notation.
func (r ApiGetRoutesRequest) ToChain(toChain string) ApiGetRoutesRequest {
	r.toChain = &toChain
	return r
}

// The address or symbol of the token to be received.
func (r ApiGetRoutesRequest) ToToken(toToken string) ApiGetRoutesRequest {
	r.toToken = &toToken
	return r
}

// The address of the wallet sending the tokens.
func (r ApiGetRoutesRequest) FromAddress(fromAddress string) ApiGetRoutesRequest {
	r.fromAddress = &fromAddress
	return r
}

// The address of the wallet receiving the tokens. This can be the same as the &#x60;fromAddress&#x60;. &#x60;fromAddress&#x60; will be used.
func (r ApiGetRoutesRequest) ToAddress(toAddress string) ApiGetRoutesRequest {
	r.toAddress = &toAddress
	return r
}

// The maximum allowed price slippage for the transaction, as a decimal fraction.
func (r ApiGetRoutesRequest) Slippage(slippage float32) ApiGetRoutesRequest {
	r.slippage = &slippage
	return r
}

// A list of bridges that are allowed for the transaction.
func (r ApiGetRoutesRequest) AllowBridges(allowBridges []string) ApiGetRoutesRequest {
	r.allowBridges = &allowBridges
	return r
}

// A list of exchanges that are allowed for the transaction.
func (r ApiGetRoutesRequest) AllowExchanges(allowExchanges []string) ApiGetRoutesRequest {
	r.allowExchanges = &allowExchanges
	return r
}

// A list of bridges that are not allowed for the transaction.
func (r ApiGetRoutesRequest) DenyBridges(denyBridges []string) ApiGetRoutesRequest {
	r.denyBridges = &denyBridges
	return r
}

// A list of exchanges that are not allowed for the transaction.
func (r ApiGetRoutesRequest) DenyExchanges(denyExchanges []string) ApiGetRoutesRequest {
	r.denyExchanges = &denyExchanges
	return r
}

func (r ApiGetRoutesRequest) Execute() (*RoutesResponse, *http.Response, error) {
	return r.ApiService.GetRoutesExecute(r)
}

/*
GetRoutes Get a list of routes for swapping assets

Provides a list of possible routes for swapping assets, detailing each route's steps, tokens, amounts, fees, and estimated execution time. This allows users to compare different options and select the most suitable route for their needs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRoutesRequest
*/
func (a *ExchangeAPIService) GetRoutes(ctx context.Context) ApiGetRoutesRequest {
	return ApiGetRoutesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RoutesResponse
func (a *ExchangeAPIService) GetRoutesExecute(r ApiGetRoutesRequest) (*RoutesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RoutesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangeAPIService.GetRoutes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exchange/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromChain == nil {
		return localVarReturnValue, nil, reportError("fromChain is required and must be specified")
	}
	if r.fromAmount == nil {
		return localVarReturnValue, nil, reportError("fromAmount is required and must be specified")
	}
	if r.fromToken == nil {
		return localVarReturnValue, nil, reportError("fromToken is required and must be specified")
	}
	if r.toChain == nil {
		return localVarReturnValue, nil, reportError("toChain is required and must be specified")
	}
	if r.toToken == nil {
		return localVarReturnValue, nil, reportError("toToken is required and must be specified")
	}
	if r.fromAddress == nil {
		return localVarReturnValue, nil, reportError("fromAddress is required and must be specified")
	}
	if r.toAddress == nil {
		return localVarReturnValue, nil, reportError("toAddress is required and must be specified")
	}
	if r.slippage == nil {
		return localVarReturnValue, nil, reportError("slippage is required and must be specified")
	}
	if *r.slippage < 0 {
		return localVarReturnValue, nil, reportError("slippage must be greater than 0")
	}
	if *r.slippage > 1 {
		return localVarReturnValue, nil, reportError("slippage must be less than 1")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromChain", r.fromChain, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromAmount", r.fromAmount, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromToken", r.fromToken, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toChain", r.toChain, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toToken", r.toToken, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromAddress", r.fromAddress, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toAddress", r.toAddress, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "slippage", r.slippage, "form", "")
	if r.allowBridges != nil {
		t := *r.allowBridges
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowBridges", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowBridges", t, "form", "multi")
		}
	}
	if r.allowExchanges != nil {
		t := *r.allowExchanges
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "allowExchanges", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "allowExchanges", t, "form", "multi")
		}
	}
	if r.denyBridges != nil {
		t := *r.denyBridges
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "denyBridges", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "denyBridges", t, "form", "multi")
		}
	}
	if r.denyExchanges != nil {
		t := *r.denyExchanges
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "denyExchanges", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "denyExchanges", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusRequest struct {
	ctx context.Context
	ApiService *ExchangeAPIService
	transactionID *string
	targetID *string
	fromChain *string
	toChain *string
}

// The ID of the transaction.
func (r ApiGetStatusRequest) TransactionID(transactionID string) ApiGetStatusRequest {
	r.transactionID = &transactionID
	return r
}

// A reference to the transaction target used. This value can be found in the routes response.
func (r ApiGetStatusRequest) TargetID(targetID string) ApiGetStatusRequest {
	r.targetID = &targetID
	return r
}

// The sending Chain ID or symbol.
func (r ApiGetStatusRequest) FromChain(fromChain string) ApiGetStatusRequest {
	r.fromChain = &fromChain
	return r
}

// The receiver of the transaction (Chain ID). This can be the same as the &#x60;fromChain&#x60; for same-chain swaps.
func (r ApiGetStatusRequest) ToChain(toChain string) ApiGetStatusRequest {
	r.toChain = &toChain
	return r
}

func (r ApiGetStatusRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.GetStatusExecute(r)
}

/*
GetStatus Get swap status

Retrieves the status of a swap by providing its transaction ID. The response includes details such as the transaction's current status and transaction hashes. This endpoint allows users to track the progress of their transactions and monitor their status across different blockchains. We recommend using additional methods to verify that the transaction has been included in a block before checking the status to avoid "not-found" response while the transaction is still in the mempool.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStatusRequest
*/
func (a *ExchangeAPIService) GetStatus(ctx context.Context) ApiGetStatusRequest {
	return ApiGetStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StatusResponse
func (a *ExchangeAPIService) GetStatusExecute(r ApiGetStatusRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExchangeAPIService.GetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exchange/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.transactionID == nil {
		return localVarReturnValue, nil, reportError("transactionID is required and must be specified")
	}
	if r.targetID == nil {
		return localVarReturnValue, nil, reportError("targetID is required and must be specified")
	}
	if r.fromChain == nil {
		return localVarReturnValue, nil, reportError("fromChain is required and must be specified")
	}
	if r.toChain == nil {
		return localVarReturnValue, nil, reportError("toChain is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "transactionID", r.transactionID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "targetID", r.targetID, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromChain", r.fromChain, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toChain", r.toChain, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
