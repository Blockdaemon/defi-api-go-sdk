/*
Blockdaemon DeFi API

The Blockdaemon DeFi API provides a single interface to a multitude of DeFi projects and blockchains

API version: 1.0.0
Contact: info@blockdaemon.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// ApprovalsAPIService ApprovalsAPI service
type ApprovalsAPIService service

type ApiDeleteTokenApprovalRequest struct {
	ctx context.Context
	ApiService *ApprovalsAPIService
	tokenApprovalDeletion *TokenApprovalDeletion
}

// The request body for a delete approval
func (r ApiDeleteTokenApprovalRequest) TokenApprovalDeletion(tokenApprovalDeletion TokenApprovalDeletion) ApiDeleteTokenApprovalRequest {
	r.tokenApprovalDeletion = &tokenApprovalDeletion
	return r
}

func (r ApiDeleteTokenApprovalRequest) Execute() (*TokenApprovalResponse, *http.Response, error) {
	return r.ApiService.DeleteTokenApprovalExecute(r)
}

/*
DeleteTokenApproval Delete an ERC20 token approval

Deletes an existing ERC20 token approval for a specified account, token, and spender. The response contains details about the deletion, including a transaction request object that can be used to execute the deletion on-chain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTokenApprovalRequest
*/
func (a *ApprovalsAPIService) DeleteTokenApproval(ctx context.Context) ApiDeleteTokenApprovalRequest {
	return ApiDeleteTokenApprovalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenApprovalResponse
func (a *ApprovalsAPIService) DeleteTokenApprovalExecute(r ApiDeleteTokenApprovalRequest) (*TokenApprovalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenApprovalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApprovalsAPIService.DeleteTokenApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenApprovalDeletion == nil {
		return localVarReturnValue, nil, reportError("tokenApprovalDeletion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenApprovalDeletion
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllApprovalsRequest struct {
	ctx context.Context
	ApiService *ApprovalsAPIService
	chainIDs *[]string
	accountAddresses *[]string
	spenderAddresses *[]string
	tokenAddresses *[]string
}

// A list of CAIP-2 identifiers for blockchains.
func (r ApiGetAllApprovalsRequest) ChainIDs(chainIDs []string) ApiGetAllApprovalsRequest {
	r.chainIDs = &chainIDs
	return r
}

// A list of account addresses to query.
func (r ApiGetAllApprovalsRequest) AccountAddresses(accountAddresses []string) ApiGetAllApprovalsRequest {
	r.accountAddresses = &accountAddresses
	return r
}

// A list of spender addresses to query. If omitted, all supported spenders will be queried.
func (r ApiGetAllApprovalsRequest) SpenderAddresses(spenderAddresses []string) ApiGetAllApprovalsRequest {
	r.spenderAddresses = &spenderAddresses
	return r
}

// A list of token contract addresses to query. If omitted, all supported tokens will be queried.
func (r ApiGetAllApprovalsRequest) TokenAddresses(tokenAddresses []string) ApiGetAllApprovalsRequest {
	r.tokenAddresses = &tokenAddresses
	return r
}

func (r ApiGetAllApprovalsRequest) Execute() (*AllApprovalsResponse, *http.Response, error) {
	return r.ApiService.GetAllApprovalsExecute(r)
}

/*
GetAllApprovals Get a list of ERC20 token approvals

Retrieves a list of ERC20 token approvals for multiple accounts across various chains, spenders, and tokens. The response includes the combined approval amounts aggregated by chain and account, allowing users to view their overall approval exposure. This endpoint is useful for monitoring and managing token approvals across multiple DeFi platforms or protocols.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllApprovalsRequest
*/
func (a *ApprovalsAPIService) GetAllApprovals(ctx context.Context) ApiGetAllApprovalsRequest {
	return ApiGetAllApprovalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllApprovalsResponse
func (a *ApprovalsAPIService) GetAllApprovalsExecute(r ApiGetAllApprovalsRequest) (*AllApprovalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllApprovalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApprovalsAPIService.GetAllApprovals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approvals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chainIDs == nil {
		return localVarReturnValue, nil, reportError("chainIDs is required and must be specified")
	}
	if r.accountAddresses == nil {
		return localVarReturnValue, nil, reportError("accountAddresses is required and must be specified")
	}

	{
		t := *r.chainIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chainIDs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chainIDs", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountAddresses", r.accountAddresses, "csv")
	if r.spenderAddresses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "spenderAddresses", r.spenderAddresses, "csv")
	}
	if r.tokenAddresses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tokenAddresses", r.tokenAddresses, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedChainsRequest struct {
	ctx context.Context
	ApiService *ApprovalsAPIService
	chainID *string
	chainName *string
	networkType *NetworkType
}

// The CAIP-2 identifier for a blockchain.
func (r ApiGetSupportedChainsRequest) ChainID(chainID string) ApiGetSupportedChainsRequest {
	r.chainID = &chainID
	return r
}

// The name of a blockchain.
func (r ApiGetSupportedChainsRequest) ChainName(chainName string) ApiGetSupportedChainsRequest {
	r.chainName = &chainName
	return r
}

// The type of network (mainnet, testnet, or devnet).
func (r ApiGetSupportedChainsRequest) NetworkType(networkType NetworkType) ApiGetSupportedChainsRequest {
	r.networkType = &networkType
	return r
}

func (r ApiGetSupportedChainsRequest) Execute() (*Chains, *http.Response, error) {
	return r.ApiService.GetSupportedChainsExecute(r)
}

/*
GetSupportedChains Get supported chains for token approvals

Retrieves a list of blockchain networks that are supported for querying token approvals. This information can be useful for clients or applications that need to know which chains are compatible with the approvals functionality.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedChainsRequest
*/
func (a *ApprovalsAPIService) GetSupportedChains(ctx context.Context) ApiGetSupportedChainsRequest {
	return ApiGetSupportedChainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Chains
func (a *ApprovalsAPIService) GetSupportedChainsExecute(r ApiGetSupportedChainsRequest) (*Chains, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chains
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApprovalsAPIService.GetSupportedChains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approvals/supported-chains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chainID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainID", r.chainID, "")
	}
	if r.chainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainName", r.chainName, "")
	}
	if r.networkType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkType", r.networkType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenApprovalRequest struct {
	ctx context.Context
	ApiService *ApprovalsAPIService
	chainID *string
	accountAddress *string
	tokenAddress *string
	spenderAddress *string
}

// The CAIP-2 identifier for a blockchain.
func (r ApiGetTokenApprovalRequest) ChainID(chainID string) ApiGetTokenApprovalRequest {
	r.chainID = &chainID
	return r
}

// The address of an account.
func (r ApiGetTokenApprovalRequest) AccountAddress(accountAddress string) ApiGetTokenApprovalRequest {
	r.accountAddress = &accountAddress
	return r
}

// The address of an token contract.
func (r ApiGetTokenApprovalRequest) TokenAddress(tokenAddress string) ApiGetTokenApprovalRequest {
	r.tokenAddress = &tokenAddress
	return r
}

// The address of a spender.
func (r ApiGetTokenApprovalRequest) SpenderAddress(spenderAddress string) ApiGetTokenApprovalRequest {
	r.spenderAddress = &spenderAddress
	return r
}

func (r ApiGetTokenApprovalRequest) Execute() (*TokenApprovalData, *http.Response, error) {
	return r.ApiService.GetTokenApprovalExecute(r)
}

/*
GetTokenApproval List ERC20 token approvals

Retrieves token approval details for a specified account, token, and spender. This includes information such as the approved amount, the chain ID, and the spender's address and name. Token approvals are required for certain DeFi interactions, and this endpoint allows users to check the current approval status for their tokens.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokenApprovalRequest
*/
func (a *ApprovalsAPIService) GetTokenApproval(ctx context.Context) ApiGetTokenApprovalRequest {
	return ApiGetTokenApprovalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenApprovalData
func (a *ApprovalsAPIService) GetTokenApprovalExecute(r ApiGetTokenApprovalRequest) (*TokenApprovalData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenApprovalData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApprovalsAPIService.GetTokenApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chainID == nil {
		return localVarReturnValue, nil, reportError("chainID is required and must be specified")
	}
	if r.accountAddress == nil {
		return localVarReturnValue, nil, reportError("accountAddress is required and must be specified")
	}
	if r.tokenAddress == nil {
		return localVarReturnValue, nil, reportError("tokenAddress is required and must be specified")
	}
	if r.spenderAddress == nil {
		return localVarReturnValue, nil, reportError("spenderAddress is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chainID", r.chainID, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "accountAddress", r.accountAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tokenAddress", r.tokenAddress, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "spenderAddress", r.spenderAddress, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyTokenApprovalRequest struct {
	ctx context.Context
	ApiService *ApprovalsAPIService
	tokenApprovalModification *TokenApprovalModification
}

// The request body for a post approval
func (r ApiModifyTokenApprovalRequest) TokenApprovalModification(tokenApprovalModification TokenApprovalModification) ApiModifyTokenApprovalRequest {
	r.tokenApprovalModification = &tokenApprovalModification
	return r
}

func (r ApiModifyTokenApprovalRequest) Execute() (*TokenApprovalResponse, *http.Response, error) {
	return r.ApiService.ModifyTokenApprovalExecute(r)
}

/*
ModifyTokenApproval Modify an ERC20 token approval

Modifies an existing ERC20 token approval by updating the approved amount for a specified account, token, and spender. The response contains details about the modification, including the previous and new approved amounts, as well as a transaction request object that can be used to execute the modification on-chain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModifyTokenApprovalRequest
*/
func (a *ApprovalsAPIService) ModifyTokenApproval(ctx context.Context) ApiModifyTokenApprovalRequest {
	return ApiModifyTokenApprovalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenApprovalResponse
func (a *ApprovalsAPIService) ModifyTokenApprovalExecute(r ApiModifyTokenApprovalRequest) (*TokenApprovalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenApprovalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApprovalsAPIService.ModifyTokenApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/approval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tokenApprovalModification == nil {
		return localVarReturnValue, nil, reportError("tokenApprovalModification is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tokenApprovalModification
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
