/*
Blockdaemon DeFi API

The Blockdaemon DeFi API provides a single interface to a multitude of DeFi projects and blockchains

API version: 1.0.0
Contact: info@blockdaemon.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// BalancesAPIService BalancesAPI service
type BalancesAPIService service

type ApiGetBalancesRequest struct {
	ctx context.Context
	ApiService *BalancesAPIService
	accountAddress *string
	chainIDs *[]string
	tokenAddress *string
}

// The address of an account.
func (r ApiGetBalancesRequest) AccountAddress(accountAddress string) ApiGetBalancesRequest {
	r.accountAddress = &accountAddress
	return r
}

// A list of CAIP-2 identifiers for blockchains.
func (r ApiGetBalancesRequest) ChainIDs(chainIDs []string) ApiGetBalancesRequest {
	r.chainIDs = &chainIDs
	return r
}

// The address of an token contract to query. If omitted, all supported tokens will be queried.
func (r ApiGetBalancesRequest) TokenAddress(tokenAddress string) ApiGetBalancesRequest {
	r.tokenAddress = &tokenAddress
	return r
}

func (r ApiGetBalancesRequest) Execute() (*BalancesResponse, *http.Response, error) {
	return r.ApiService.GetBalancesExecute(r)
}

/*
GetBalances Get token balances and market data for an account

Retrieves the individual token balances and market data for an account across multiple blockchain networks. The response includes the account's token holdings, their current market value, and other relevant information, such as the token's name, symbol, and logo URI. This endpoint is useful for displaying a consolidated view of a user's portfolio across different chains and tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBalancesRequest
*/
func (a *BalancesAPIService) GetBalances(ctx context.Context) ApiGetBalancesRequest {
	return ApiGetBalancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BalancesResponse
func (a *BalancesAPIService) GetBalancesExecute(r ApiGetBalancesRequest) (*BalancesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalancesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BalancesAPIService.GetBalances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountAddress == nil {
		return localVarReturnValue, nil, reportError("accountAddress is required and must be specified")
	}
	if r.chainIDs == nil {
		return localVarReturnValue, nil, reportError("chainIDs is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "accountAddress", r.accountAddress, "")
	if r.tokenAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tokenAddress", r.tokenAddress, "")
	}
	{
		t := *r.chainIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "chainIDs", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "chainIDs", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedChainsForBalancesRequest struct {
	ctx context.Context
	ApiService *BalancesAPIService
	chainID *string
	chainName *string
	networkType *NetworkType
}

// The CAIP-2 identifier for a blockchain.
func (r ApiGetSupportedChainsForBalancesRequest) ChainID(chainID string) ApiGetSupportedChainsForBalancesRequest {
	r.chainID = &chainID
	return r
}

// The name of a blockchain.
func (r ApiGetSupportedChainsForBalancesRequest) ChainName(chainName string) ApiGetSupportedChainsForBalancesRequest {
	r.chainName = &chainName
	return r
}

// The type of network (mainnet, testnet, or devnet).
func (r ApiGetSupportedChainsForBalancesRequest) NetworkType(networkType NetworkType) ApiGetSupportedChainsForBalancesRequest {
	r.networkType = &networkType
	return r
}

func (r ApiGetSupportedChainsForBalancesRequest) Execute() (*Chains, *http.Response, error) {
	return r.ApiService.GetSupportedChainsForBalancesExecute(r)
}

/*
GetSupportedChainsForBalances Get supported chains for token balance queries

Retrieves a list of blockchain networks that are supported for querying token balances. This information can be useful for clients or applications that need to know which chains are compatible with the token balances functionality.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSupportedChainsForBalancesRequest
*/
func (a *BalancesAPIService) GetSupportedChainsForBalances(ctx context.Context) ApiGetSupportedChainsForBalancesRequest {
	return ApiGetSupportedChainsForBalancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Chains
func (a *BalancesAPIService) GetSupportedChainsForBalancesExecute(r ApiGetSupportedChainsForBalancesRequest) (*Chains, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Chains
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BalancesAPIService.GetSupportedChainsForBalances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/balances/supported-chains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chainID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainID", r.chainID, "")
	}
	if r.chainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainName", r.chainName, "")
	}
	if r.networkType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkType", r.networkType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
